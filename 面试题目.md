## 目录

* [使用CSS画一个三角形](#使用CSS画一个三角形)
* [数组排序](#数组排序)

### 使用CSS画一个三角形

```html

<!DOCTYPE html>  
<html>  
<head>  
    <title>test</title>  
    <style type="text/css">  
        #triangle {  
            /*1.内容区面积为0*/  
            width: 0;  
            height: 0;  
            /*2.设置边框样式*/  
            border: 10px solid;  
            border-color: white white red white;  
        }  
    </style>  
</head>  
<body>  
    <div id="triangle"></div>  
</body>  
</html>

```

### 数组排序

```javascript
a - b < 0 a 排在 b 前面 
a - b = 0 顺序不变
a - b > 0 a 排在 b 后面 

给下列数组排序
const a = [
{ age: 51 },{ age: 23 },{ age: 53 },{ age: 12 },{ age: 24 },{ age: 33 }
];

法1：
a.sort((a,b)=>a.age-b.age);

法2：
function sort(arr) {
    return arr.sort(({age: a}, {age: b}) => a - b);
}
```

### 原型和实例

```javascript
class Test {
    // 实例上
    name = '';
    // 原型上
    log() {}
    // 实例上
    log1 = () => {};
}

1.属性定义在实例上，每个实例的name属性值相互独立
2.方法定义在原型上，Test的所有实例共享同一个log方法
3.使用箭头函数定义的方法定义在实例上而不是原型上，因为箭头函数会在每个实例被创建时重新计算，所以log1是实例方法

class Test {
    name = 'Test';
    log = () => console.log(this.name);
}
等价于
class Test {
    constructor() {
        this.name = 'Test';
        this.log = () => console.log(this.name);
    }
}
```

### 箭头函数和普通函数的区别

```
箭头函数和普通函数有什么区别？
箭头函数为什么不能用作构造函数？

区别：

1. 箭头函数在一些情况下书写更简洁（如只有一个参数、函数体直接返回值时候）。

2. 箭头函数没有自己的this，箭头函数内的this变量指向外层非箭头函数的函数的this，或者将该箭头函数作为属性的对象。箭头函数也不支持call()/apply()函数特性。

3. 箭头函数内部不可以使用arguments对象。

4. 箭头函数不可以当做构造函数。

为什么不能用作构造函数：

构造函数是通过new关键字来生成对象实例，生成对象实例的过程也是通过构造函数给实例绑定this的过程，而箭头函数没有自己的this。创建对象过程，new 首先会创建一个空对象，并将这个空对象的__proto__指向构造函数的prototype，从而继承原型上的方法，但是箭头函数没有prototype。因此不能使用箭头作为构造函数，也就不能通过new操作符来调用箭头函数。
```

### 代码执行结果-事件循环

```javascript
1.
const promise = new Promise((resolve,reject)=>{
    console.log(1);
    resolve();
    console.log(2);
    reject()
})
setTimeout(()=>{console.log(5)},0)
promise.then(()=>{console.log(3)})
.then(()=>{console.log(6)})
.catch(()=>{console.log(7)})
console.log(4)

输出：1，2，4，3，6，5

在new Primise时首先输出1，2，
异步事件：然后把setTimeout加入宏任务队列中，promise加入微任务队列中
同步事件：然后执行4，同步代码执行完毕后，执行promise的3，6，由于已经完成，所以7不执行
最后执行setTimeout的5

2.
setTimeout(function() {
    console.log(1);
}, 0);
console.log(2);
async function s1() {
    console.log(7)
    await s2();
    console.log(8);
}
async function s2() {
    console.log(9);
}
s1();
new Promise((resolve, reject) => {
    console.log(3);
    resolve();
    console.log(6);
}).then(() => console.log(4))
console.log(5);

输出：2，7，9，3，6，5，8，4，1

首先输出2，7，然后进入s2，输出9，由于s1 await s2 的结果，而s2被放进队列中没有执行，所以s1剩下的8没有输出，被放入微队列
接着输出promise的3，6，由于promise是resolve的，then被放入微队列，此时微队列有s1,then
然后输出5，同步完成后开始检查微任务队列，s2执行结束后s1继续执行输出9，then执行输出4
最后执行setTimeout输出1

在Js中，事件循环的执行顺序是：

1.首先执行同步代码
2.同步代码执行完毕后，检测微任务队列，微任务包括Promise的then和catch方法，以及MutationObserver的回调函数，果微任务队列不为空，则执行微任务队列中的所有任务，直到微任务队列为空。
3.当微任务队列为空后，执行一个宏任务。宏任务包括setTimeout和setInterval的回调函数，以及UI渲染事件。
4.执行完一个宏任务后，再次检查微任务队列，如果微任务队列不为空，则执行微任务队列中的所有任务。
5.重复步骤3和步骤4，直到宏任务队列和微任务队列都为空，事件循环结束。
```
